"""Debater agents for the multi-agent debate system."""

from __future__ import annotations

from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from pathlib import Path

from agents.llm_wrapper import VicunaWrapper, GenerationParams
from agents.heat import HeatDetector, HeatMetrics
from agents.bandit import ContextualBandit, StrategyResult, DebateOutcome
from agents.result_types import DebateArgumentResult


@dataclass
class DebaterPersona:
    """Defines a debater's personality and approach."""
    name: str
    role: str  # "pro" or "anti"
    personality: str
    aggression_level: float  # 0.0 to 1.0
    preferred_strategies: List[str]


@dataclass
class DebateContext:
    """Context information for a debate turn."""
    topic: str
    turn_number: int
    conversation_history: List[Dict[str, str]]
    retrieved_passages: List[str]
    opponent_last_message: str
    current_heat_level: float
    opponent_heat_level: float
    current_speaker: str
    retriever: Optional[Any] = None  # HybridRetriever


class Debater:
    """A debate agent that can argue for or against a position."""
    
    def __init__(
        self,
        persona: DebaterPersona,
        llm_wrapper: VicunaWrapper,
        bandit: ContextualBandit,
        heat_detector: HeatDetector,
        memory_path: Optional[Path] = None
    ):
        self.persona = persona
        self.llm = llm_wrapper
        self.bandit = bandit
        self.heat_detector = heat_detector
        self.memory_path = memory_path
        
        # Conversation memory
        self.conversation_history: List[Dict[str, str]] = []
        self.personal_memory: List[str] = []
        # Mediator influence state (temporary context applied when mediator intervenes)
        self.mediator_influence: Dict[str, Any] = {}
        # Cooling factor applied when mediator intervenes (multiplicative, 0..1)
        self.cooling_factor: float = 1.0
        # Temporary TTL (turns) for cooling effects
        self._cooling_ttl: int = 0
        # Store original aggression to restore after cooling expires
        self._original_aggression = self.persona.aggression_level

        # Performance tracking
        self.debate_stats = {
            "turns_taken": 0,
            "strategies_used": {},
            "avg_heat_generated": 0.0,
            "interventions_caused": 0
        }
    
    def generate_argument(
        self, 
        context: DebateContext,
        force_strategy: Optional[str] = None
    ) -> DebateArgumentResult:
        """Generate an argument for the current debate turn."""
        
        # Select strategy using bandit algorithm
        bandit_context = {
            "heat_level": context.current_heat_level,
            "turn_number": context.turn_number,
            "opponent_heat": context.opponent_heat_level
        }
        
        strategy = force_strategy or self.bandit.select_strategy(bandit_context)
        
        # Adjust generation parameters based on persona and heat
        params = self._get_generation_params(context.current_heat_level)
        
        # Create prompt for LLM
        prompt = self._create_debate_prompt(context, strategy)
        
        # Generate response
        if hasattr(self.llm, 'generate_response'):
            # Check if it's LlamaCppWrapper (doesn't support conversation_history)
            if hasattr(self.llm, 'llm'):  # LlamaCppWrapper has 'llm' attribute
                response = self.llm.generate_response(prompt, params)
            else:  # VicunaWrapper supports conversation_history
                response = self.llm.generate_response(prompt, params, conversation_history=context.conversation_history)
        else:
            response = "I'm having trouble generating a response right now."
        
        # Clean up response
        response = self._clean_response(response)
        
        # Analyze heat generated by our response
        heat_metrics = self.heat_detector.analyze_heat(response, self.persona.name)
        
        # Update conversation history
        self._update_memory(context, response, strategy)
        
        # Update statistics
        self._update_stats(strategy, heat_metrics)

        # Decrement cooling TTL and mediator influence timestamp
        if self._cooling_ttl > 0:
            self._cooling_ttl -= 1
            if self._cooling_ttl == 0:
                # restore original aggression
                try:
                    self.persona.aggression_level = self._original_aggression
                except Exception:
                    pass
                self.cooling_factor = 1.0
        
        # Decrement mediator influence timestamp
        if self.mediator_influence and 'timestamp' in self.mediator_influence:
            self.mediator_influence['timestamp'] -= 1
            if self.mediator_influence['timestamp'] <= 0:
                # Clear mediator influence after it expires
                self.mediator_influence.clear()
        
        return DebateArgumentResult(
            content=response,
            strategy=strategy,
            heat_score=heat_metrics.heat_score,
            heat_metrics=heat_metrics,
            retrieved_passages=context.retrieved_passages,
            generation_params=params.__dict__ if hasattr(params, '__dict__') else {}
        )


    def process_mediator_intervention(self, mediator_name: str, content: str, cooling_effect: float, ttl: int = 2) -> None:
        """Process a mediator intervention so the debater "perceives" and reacts.

        This appends the mediator message to the debater's local memory, applies a
        multiplicative cooling factor to generation parameters, and temporarily
        reduces aggression.
        """
        # Append mediator message to local conversation history and personal memory
        self.conversation_history.append({
            "speaker": mediator_name,
            "content": content,
            "turn": None,
            "strategy": "mediator"
        })

        # Store mediator guidance prominently in personal memory
        mediator_entry = f"MEDIATOR INTERVENTION - {mediator_name}: {content[:300]} [Cooling: {cooling_effect:.2f}]"
        self.personal_memory.insert(0, mediator_entry)  # Insert at beginning for priority
        if len(self.personal_memory) > 200:
            self.personal_memory = self.personal_memory[:200]
        
        # Store mediator influence state for reference
        self.mediator_influence = {
            "name": mediator_name,
            "content": content,
            "cooling_effect": cooling_effect,
            "timestamp": ttl
        }

        # Analyze mediator content heat (usually neutral/cooling)
        try:
            mediator_metrics = self.heat_detector.analyze_heat(content, mediator_name)
        except Exception:
            mediator_metrics = None

        # Compute cooling multiplier; use mediator emotional_intensity if available
        intensity = mediator_metrics.emotional_intensity if mediator_metrics is not None else 0.0
        multiplier = 1.0 - cooling_effect * (0.5 + intensity * 0.5)
        multiplier = max(0.0, min(1.0, multiplier))

        # Apply multiplicative cooling to temperature and aggression influence
        self.cooling_factor *= multiplier
        # Temporarily reduce persona aggression
        try:
            self._original_aggression = getattr(self, '_original_aggression', self.persona.aggression_level)
            self.persona.aggression_level = max(0.0, self.persona.aggression_level * multiplier)
        except Exception:
            pass

        # Set TTL for cooling to apply across next few turns
        self._cooling_ttl = max(self._cooling_ttl, ttl)
        
    
    def receive_feedback(
        self, 
        strategy: str, 
        outcome: DebateOutcome,
        heat_generated: float,
        opponent_heat: float,
        turn_number: int
    ) -> None:
        """Receive feedback about the effectiveness of a strategy."""
        result = StrategyResult(
            strategy=strategy,
            outcome=outcome,
            heat_generated=heat_generated,
            opponent_heat=opponent_heat,
            audience_engagement=0.5,  # Placeholder
            turn_number=turn_number
        )
        
        self.bandit.update_strategy(strategy, result)
    
    # ... existing methods ...
    
    def _clean_response(self, response: str) -> str:
        """Clean up the generated response."""
        # Remove any system artifacts
        response = response.strip()
        
        # Remove repeated phrases (simple approach)
        lines = response.split('\n')
        cleaned_lines = []
        for line in lines:
            line = line.strip()
            if line and line not in cleaned_lines[-3:]:  # Avoid recent repetition
                cleaned_lines.append(line)
        
        response = ' '.join(cleaned_lines)
        
        # Ensure reasonable length
        sentences = response.split('. ')
        if len(sentences) > 4:
            response = '. '.join(sentences[:4]) + '.'
        
        return response
    
    def _update_memory(
        self, 
        context: DebateContext, 
        response: str, 
        strategy: str
    ) -> None:
        """Update conversation and personal memory."""
        # Add to conversation history
        self.conversation_history.append({
            "speaker": self.persona.name,
            "content": response,
            "turn": context.turn_number,
            "strategy": strategy
        })
        
        # Keep conversation history manageable
        if len(self.conversation_history) > 20:
            self.conversation_history = self.conversation_history[-20:]
        
        # Add to personal memory (key insights, strategies that worked)
        memory_entry = f"Turn {context.turn_number}: Used {strategy} strategy. Response: {response[:100]}..."
        self.personal_memory.append(memory_entry)
        
        if len(self.personal_memory) > 50:
            self.personal_memory = self.personal_memory[-50:]
    
    def _update_stats(self, strategy: str, heat_metrics: HeatMetrics) -> None:
        """Update internal statistics."""
        self.debate_stats["turns_taken"] += 1
        
        if strategy not in self.debate_stats["strategies_used"]:
            self.debate_stats["strategies_used"][strategy] = 0
        self.debate_stats["strategies_used"][strategy] += 1
        
        # Update average heat generated
        current_avg = self.debate_stats["avg_heat_generated"]
        turns = self.debate_stats["turns_taken"]
        new_avg = ((current_avg * (turns - 1)) + heat_metrics.heat_score) / turns
        self.debate_stats["avg_heat_generated"] = new_avg
    
    def get_strategy_preferences(self) -> Dict[str, float]:
        """Get current strategy preferences based on learning."""
        rankings = self.bandit.get_strategy_rankings()
        return {strategy: score for strategy, score in rankings}
    
    def reset_for_new_debate(self) -> None:
        """Reset state for a new debate."""
        self.conversation_history.clear()
        # Keep personal memory across debates for learning
        
    def _extract_mediator_guidance(self, context: DebateContext) -> str:
        """Extract recent mediator messages and guidance for prompt context."""
        mediator_messages = []
        recent_mediator_guidance = ""
        
        # Look for mediator messages in recent conversation history
        for msg in context.conversation_history[-5:]:  # Check last 5 messages
            if msg.get('strategy') == 'mediator' or 'mediator' in msg.get('speaker', '').lower():
                mediator_messages.append(msg)
        
        # Also check personal memory for recent mediator interventions
        for memory in self.personal_memory[-10:]:
            if memory.startswith('Mediator'):
                recent_mediator_guidance = memory
                break
        
        if mediator_messages:
            latest_mediator = mediator_messages[-1]
            guidance_text = f"IMPORTANT MEDIATOR GUIDANCE: {latest_mediator['speaker']} just said: '{latest_mediator['content']}'. You must acknowledge this guidance and adjust your tone accordingly. "
            
            # Determine what the mediator is asking for
            content_lower = latest_mediator['content'].lower()
            if any(word in content_lower for word in ['calm', 'step back', 'focus', 'respectful', 'constructive']):
                guidance_text += "The mediator wants you to be more calm and respectful. Tone down your aggression and focus on facts."
            elif any(word in content_lower for word in ['common ground', 'understand', 'perspective']):
                guidance_text += "The mediator wants you to find common ground. Show understanding while still maintaining your position."
            elif any(word in content_lower for word in ['evidence', 'facts', 'substantive']):
                guidance_text += "The mediator wants more evidence-based discussion. Focus on facts and logical arguments."
            else:
                guidance_text += "The mediator wants you to adjust your approach. Be more diplomatic while keeping your position."
            
            return guidance_text
        
        return ""

    def _create_debate_prompt(self, context: DebateContext, strategy: str) -> str:
        """Create a debate prompt for the LLM with emotional context and mediator guidance."""
        # Check if we're using DialoGPT
        is_dialogpt = hasattr(self.llm, 'actual_model_name') and (
            "DialoGPT" in self.llm.actual_model_name or "dialogpt" in self.llm.actual_model_name.lower()
        )
        
        if is_dialogpt:
            # More detailed conversational format for DialoGPT
            if context.opponent_last_message:
                # Respond to opponent with more context
                prompt = f"In a debate about whether {context.topic.lower()}, {self.persona.name} argues {self.persona.role} regulation. Previous: {context.opponent_last_message} {self.persona.name} responds:"
            else:
                # Opening statement with clear stance
                prompt = f"In a debate about whether {context.topic.lower()}, {self.persona.name} argues {self.persona.role} regulation and says:"
            return prompt
        else:
            # Complex instruction format for other models with emotional context and mediator guidance
            # Build conversation history with emphasis on mediator messages
            history_text = ""
            mediator_present = False
            for msg in context.conversation_history[-5:]:  # Increased to 5 messages to catch mediator
                speaker_prefix = "[MEDIATOR]" if msg.get('strategy') == 'mediator' else ""
                history_text += f"{speaker_prefix}{msg['speaker']}: {msg['content']}\n"
                if msg.get('strategy') == 'mediator':
                    mediator_present = True
            
            # Build retrieved passages
            passages_text = ""
            if context.retrieved_passages:
                passages_text = "\n".join([f"- {passage}" for passage in context.retrieved_passages[:3]])
            
            # Extract mediator guidance
            mediator_guidance = self._extract_mediator_guidance(context)
            
            # Determine emotional context (adjusted for mediator presence)
            emotional_context = self._get_emotional_context(context, mediator_present)
            
            # Create the prompt with mediator guidance priority
            if mediator_guidance:
                # Mediator is present - prioritize their guidance
                prompt = f"""You are {self.persona.name}, arguing {self.persona.role} "{context.topic}".

{mediator_guidance}

{emotional_context}

Recent Conversation (pay special attention to [MEDIATOR] messages):
{history_text[-300:] if history_text else "Opening statement"}

Evidence: {passages_text[:150] if passages_text else "No specific evidence"}
Opponent: {context.opponent_last_message[:100] if context.opponent_last_message else "No previous message"}

Respond as {self.persona.name} using {strategy} strategy. IMPORTANT: You must acknowledge and respond to the mediator's guidance while maintaining your position. Be respectful to the mediator's authority while still making your point effectively. Keep it under 3 sentences.

{self.persona.name}:"""
            else:
                # No mediator - use normal emotional approach
                prompt = f"""You are {self.persona.name}, arguing {self.persona.role} "{context.topic}".

{emotional_context}

Recent: {history_text[-200:] if history_text else "Opening statement"}
Evidence: {passages_text[:150] if passages_text else "No specific evidence"}
Opponent: {context.opponent_last_message[:100] if context.opponent_last_message else "No previous message"}

Respond as {self.persona.name} using {strategy} strategy. Be EXTREMELY emotional, confrontational, and heated like a real human debate! Use the strongest possible language, challenge your opponent directly, show intense anger/frustration/outrage! Be dramatic and passionate! Keep it under 3 sentences but make them explosive and emotional!

{self.persona.name}:"""
            
            return prompt
    
    def _get_emotional_context(self, context: DebateContext, mediator_present: bool = False) -> str:
        """Generate emotional context based on the current situation and mediator presence."""
        heat_level = context.current_heat_level
        opponent_heat = context.opponent_heat_level
        turn_number = context.turn_number
        
        # Apply cooling effect if mediator recently intervened
        effective_heat = heat_level * self.cooling_factor
        effective_aggression = self.persona.aggression_level
        
        # If mediator is present, significantly moderate the emotional instructions
        if mediator_present:
            if effective_heat > 0.8:
                return "The mediator has intervened. You're still passionate about your position but you must show respect for the mediator's authority. Be firm but diplomatic. Acknowledge the mediator's guidance while defending your viewpoint with controlled intensity."
            elif effective_heat > 0.6:
                return "The mediator has spoken. You need to tone down your approach while still being assertive. Show that you're listening to the mediator while maintaining your strong convictions. Be passionate but respectful."
            elif effective_heat > 0.3:
                return "The mediator wants calmer discussion. You should acknowledge their guidance and demonstrate more measured reasoning while still being confident in your position. Show respect for the mediation process."
            else:
                return "The mediator has provided guidance. You should explicitly acknowledge their input and show how you're adjusting your approach to be more constructive while maintaining your stance."
        
        # Normal emotional escalation when no mediator is present
        if effective_heat > 0.8:
            if opponent_heat > 0.7:
                return "You're ABSOLUTELY FURIOUS and completely outraged! Your opponent is being totally unreasonable and you're about to explode with anger! Use the strongest possible language: 'absolutely ridiculous', 'completely absurd', 'totally unacceptable', 'how dare you'! Show you're seething with rage!"
            else:
                return "You're EXTREMELY passionate and heated! You're practically shouting with conviction! Use dramatic, emphatic language and show you care deeply about this issue!"
        elif heat_level > 0.6:
            if turn_number <= 2:
                return "You're getting VERY heated and confrontational! Use strong, aggressive language and challenge your opponent directly! Show you're not backing down and you're ready to fight!"
            else:
                return "You're frustrated and annoyed! Express your irritation with dismissive, contemptuous language! Show you think their arguments are weak and stupid!"
        elif heat_level > 0.3:
            if turn_number <= 2:
                return "You're confident and getting aggressive! Use confrontational language and challenge your opponent's position directly! Be assertive and pushy!"
            else:
                return "You're becoming angry and defensive! Express frustration and use stronger language to push back! Show you're getting irritated!"
        else:
            if turn_number <= 2:
                return "You're assertive and ready to fight from the start! Use confident, challenging language and be confrontational!"
            else:
                return "You're getting frustrated! Express annoyance and use dismissive language! Show contempt!"
        
        return "You're aggressive and confrontational! Challenge everything your opponent says with strong, emotional language!"
    
    def _get_generation_params(self, heat_level: float) -> GenerationParams:
        """Get generation parameters based on heat level, persona, and mediator influence."""
        # Adjust temperature based on heat level and aggression
        base_temp = 1.0
        heat_multiplier = 1.0 + (heat_level * 0.4)
        aggression_multiplier = 1.0 + (self.persona.aggression_level * 0.3)
        
        temperature = min(1.4, base_temp * heat_multiplier * aggression_multiplier)
        
        # Apply cooling factor from mediator interventions (stronger effect)
        temperature = max(0.1, temperature * self.cooling_factor)
        
        # Additional mediator influence - if recent intervention, be more conservative
        if self.mediator_influence and self.mediator_influence.get('timestamp', 0) > 0:
            # Mediator recently intervened - reduce temperature further and increase repetition penalty
            temperature *= 0.7  # Additional cooling
            repetition_penalty = 1.2  # More controlled responses
            top_p = 0.85  # Less diverse, more focused
        else:
            repetition_penalty = 1.15
            top_p = 0.95

        return GenerationParams(
            max_new_tokens=100,  # Slightly longer for more thoughtful responses
            temperature=temperature,
            do_sample=True,
            top_p=top_p,
            top_k=50,
            repetition_penalty=repetition_penalty
        )
    
    def _clean_response(self, response: str) -> str:
        """Clean up the generated response."""
        # Remove any unwanted prefixes
        if "Your argument:" in response:
            response = response.split("Your argument:")[-1].strip()
        
        # Remove any role indicators
        response = response.replace(f"{self.persona.name}:", "").strip()
        
        # Limit length
        if len(response) > 500:
            response = response[:500] + "..."
        
        return response.strip()

    def get_stats(self) -> Dict[str, Any]:
        """Get debater statistics."""
        return {
            "persona": {
                "name": self.persona.name,
                "role": self.persona.role,
                "personality": self.persona.personality,
                "aggression_level": self.persona.aggression_level
            },
            "performance": self.debate_stats,
            "strategy_preferences": self.get_strategy_preferences(),
            "bandit_recommendations": self.bandit.get_recommendations()
        }
